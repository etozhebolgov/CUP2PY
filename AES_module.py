dictionary = {
 '0': [[0, 0, 0, 0, 0, 0, 0, 0], 99, 82],
 '1': [[0, 0, 0, 0, 0, 0, 0, 1], 124, 9],
 '2': [[0, 0, 0, 0, 0, 0, 1, 0], 119, 106],
 '3': [[0, 0, 0, 0, 0, 0, 1, 1], 123, 213],
 '4': [[0, 0, 0, 0, 0, 1, 0, 0], 242, 48],
 '5': [[0, 0, 0, 0, 0, 1, 0, 1], 107, 54],
 '6': [[0, 0, 0, 0, 0, 1, 1, 0], 111, 165],
 '7': [[0, 0, 0, 0, 0, 1, 1, 1], 197, 56],
 '8': [[0, 0, 0, 0, 1, 0, 0, 0], 48, 191],
 '9': [[0, 0, 0, 0, 1, 0, 0, 1], 1, 64],
 '10': [[0, 0, 0, 0, 1, 0, 1, 0], 103, 163],
 '11': [[0, 0, 0, 0, 1, 0, 1, 1], 43, 158],
 '12': [[0, 0, 0, 0, 1, 1, 0, 0], 254, 129],
 '13': [[0, 0, 0, 0, 1, 1, 0, 1], 215, 243],
 '14': [[0, 0, 0, 0, 1, 1, 1, 0], 171, 215],
 '15': [[0, 0, 0, 0, 1, 1, 1, 1], 118, 251],
 '16': [[0, 0, 0, 1, 0, 0, 0, 0], 202, 124],
 '17': [[0, 0, 0, 1, 0, 0, 0, 1], 130, 227],
 '18': [[0, 0, 0, 1, 0, 0, 1, 0], 201, 57],
 '19': [[0, 0, 0, 1, 0, 0, 1, 1], 125, 130],
 '20': [[0, 0, 0, 1, 0, 1, 0, 0], 250, 155],
 '21': [[0, 0, 0, 1, 0, 1, 0, 1], 89, 47],
 '22': [[0, 0, 0, 1, 0, 1, 1, 0], 71, 255],
 '23': [[0, 0, 0, 1, 0, 1, 1, 1], 240, 135],
 '24': [[0, 0, 0, 1, 1, 0, 0, 0], 173, 52],
 '25': [[0, 0, 0, 1, 1, 0, 0, 1], 212, 142],
 '26': [[0, 0, 0, 1, 1, 0, 1, 0], 162, 67],
 '27': [[0, 0, 0, 1, 1, 0, 1, 1], 175, 68],
 '28': [[0, 0, 0, 1, 1, 1, 0, 0], 156, 196],
 '29': [[0, 0, 0, 1, 1, 1, 0, 1], 164, 222],
 '30': [[0, 0, 0, 1, 1, 1, 1, 0], 114, 233],
 '31': [[0, 0, 0, 1, 1, 1, 1, 1], 192, 203],
 '32': [[0, 0, 1, 0, 0, 0, 0, 0], 183, 84],
 '33': [[0, 0, 1, 0, 0, 0, 0, 1], 253, 123],
 '34': [[0, 0, 1, 0, 0, 0, 1, 0], 147, 148],
 '35': [[0, 0, 1, 0, 0, 0, 1, 1], 38, 50],
 '36': [[0, 0, 1, 0, 0, 1, 0, 0], 54, 166],
 '37': [[0, 0, 1, 0, 0, 1, 0, 1], 63, 194],
 '38': [[0, 0, 1, 0, 0, 1, 1, 0], 247, 35],
 '39': [[0, 0, 1, 0, 0, 1, 1, 1], 204, 61],
 '40': [[0, 0, 1, 0, 1, 0, 0, 0], 52, 238],
 '41': [[0, 0, 1, 0, 1, 0, 0, 1], 165, 76],
 '42': [[0, 0, 1, 0, 1, 0, 1, 0], 229, 149],
 '43': [[0, 0, 1, 0, 1, 0, 1, 1], 241, 11],
 '44': [[0, 0, 1, 0, 1, 1, 0, 0], 113, 66],
 '45': [[0, 0, 1, 0, 1, 1, 0, 1], 216, 250],
 '46': [[0, 0, 1, 0, 1, 1, 1, 0], 49, 195],
 '47': [[0, 0, 1, 0, 1, 1, 1, 1], 21, 78],
 '48': [[0, 0, 1, 1, 0, 0, 0, 0], 4, 8],
 '49': [[0, 0, 1, 1, 0, 0, 0, 1], 199, 46],
 '50': [[0, 0, 1, 1, 0, 0, 1, 0], 35, 161],
 '51': [[0, 0, 1, 1, 0, 0, 1, 1], 195, 102],
 '52': [[0, 0, 1, 1, 0, 1, 0, 0], 24, 40],
 '53': [[0, 0, 1, 1, 0, 1, 0, 1], 150, 217],
 '54': [[0, 0, 1, 1, 0, 1, 1, 0], 5, 36],
 '55': [[0, 0, 1, 1, 0, 1, 1, 1], 154, 178],
 '56': [[0, 0, 1, 1, 1, 0, 0, 0], 7, 118],
 '57': [[0, 0, 1, 1, 1, 0, 0, 1], 18, 91],
 '58': [[0, 0, 1, 1, 1, 0, 1, 0], 128, 162],
 '59': [[0, 0, 1, 1, 1, 0, 1, 1], 226, 73],
 '60': [[0, 0, 1, 1, 1, 1, 0, 0], 235, 109],
 '61': [[0, 0, 1, 1, 1, 1, 0, 1], 39, 139],
 '62': [[0, 0, 1, 1, 1, 1, 1, 0], 178, 209],
 '63': [[0, 0, 1, 1, 1, 1, 1, 1], 117, 37],
 '64': [[0, 1, 0, 0, 0, 0, 0, 0], 9, 114],
 '65': [[0, 1, 0, 0, 0, 0, 0, 1], 131, 248],
 '66': [[0, 1, 0, 0, 0, 0, 1, 0], 44, 246],
 '67': [[0, 1, 0, 0, 0, 0, 1, 1], 26, 100],
 '68': [[0, 1, 0, 0, 0, 1, 0, 0], 27, 134],
 '69': [[0, 1, 0, 0, 0, 1, 0, 1], 110, 104],
 '70': [[0, 1, 0, 0, 0, 1, 1, 0], 90, 152],
 '71': [[0, 1, 0, 0, 0, 1, 1, 1], 160, 22],
 '72': [[0, 1, 0, 0, 1, 0, 0, 0], 82, 212],
 '73': [[0, 1, 0, 0, 1, 0, 0, 1], 59, 164],
 '74': [[0, 1, 0, 0, 1, 0, 1, 0], 214, 92],
 '75': [[0, 1, 0, 0, 1, 0, 1, 1], 179, 204],
 '76': [[0, 1, 0, 0, 1, 1, 0, 0], 41, 93],
 '77': [[0, 1, 0, 0, 1, 1, 0, 1], 227, 101],
 '78': [[0, 1, 0, 0, 1, 1, 1, 0], 47, 182],
 '79': [[0, 1, 0, 0, 1, 1, 1, 1], 132, 146],
 '80': [[0, 1, 0, 1, 0, 0, 0, 0], 83, 108],
 '81': [[0, 1, 0, 1, 0, 0, 0, 1], 209, 112],
 '82': [[0, 1, 0, 1, 0, 0, 1, 0], 0, 72],
 '83': [[0, 1, 0, 1, 0, 0, 1, 1], 237, 80],
 '84': [[0, 1, 0, 1, 0, 1, 0, 0], 32, 253],
 '85': [[0, 1, 0, 1, 0, 1, 0, 1], 252, 237],
 '86': [[0, 1, 0, 1, 0, 1, 1, 0], 177, 185],
 '87': [[0, 1, 0, 1, 0, 1, 1, 1], 91, 218],
 '88': [[0, 1, 0, 1, 1, 0, 0, 0], 106, 94],
 '89': [[0, 1, 0, 1, 1, 0, 0, 1], 203, 21],
 '90': [[0, 1, 0, 1, 1, 0, 1, 0], 190, 70],
 '91': [[0, 1, 0, 1, 1, 0, 1, 1], 57, 87],
 '92': [[0, 1, 0, 1, 1, 1, 0, 0], 74, 167],
 '93': [[0, 1, 0, 1, 1, 1, 0, 1], 76, 141],
 '94': [[0, 1, 0, 1, 1, 1, 1, 0], 88, 157],
 '95': [[0, 1, 0, 1, 1, 1, 1, 1], 207, 132],
 '96': [[0, 1, 1, 0, 0, 0, 0, 0], 208, 144],
 '97': [[0, 1, 1, 0, 0, 0, 0, 1], 239, 216],
 '98': [[0, 1, 1, 0, 0, 0, 1, 0], 170, 171],
 '99': [[0, 1, 1, 0, 0, 0, 1, 1], 251, 0],
 '100': [[0, 1, 1, 0, 0, 1, 0, 0], 67, 140],
 '101': [[0, 1, 1, 0, 0, 1, 0, 1], 77, 188],
 '102': [[0, 1, 1, 0, 0, 1, 1, 0], 51, 211],
 '103': [[0, 1, 1, 0, 0, 1, 1, 1], 133, 10],
 '104': [[0, 1, 1, 0, 1, 0, 0, 0], 69, 247],
 '105': [[0, 1, 1, 0, 1, 0, 0, 1], 249, 228],
 '106': [[0, 1, 1, 0, 1, 0, 1, 0], 2, 88],
 '107': [[0, 1, 1, 0, 1, 0, 1, 1], 127, 5],
 '108': [[0, 1, 1, 0, 1, 1, 0, 0], 80, 184],
 '109': [[0, 1, 1, 0, 1, 1, 0, 1], 60, 179],
 '110': [[0, 1, 1, 0, 1, 1, 1, 0], 159, 69],
 '111': [[0, 1, 1, 0, 1, 1, 1, 1], 168, 6],
 '112': [[0, 1, 1, 1, 0, 0, 0, 0], 81, 208],
 '113': [[0, 1, 1, 1, 0, 0, 0, 1], 163, 44],
 '114': [[0, 1, 1, 1, 0, 0, 1, 0], 64, 30],
 '115': [[0, 1, 1, 1, 0, 0, 1, 1], 143, 143],
 '116': [[0, 1, 1, 1, 0, 1, 0, 0], 146, 202],
 '117': [[0, 1, 1, 1, 0, 1, 0, 1], 157, 63],
 '118': [[0, 1, 1, 1, 0, 1, 1, 0], 56, 15],
 '119': [[0, 1, 1, 1, 0, 1, 1, 1], 245, 2],
 '120': [[0, 1, 1, 1, 1, 0, 0, 0], 188, 193],
 '121': [[0, 1, 1, 1, 1, 0, 0, 1], 182, 175],
 '122': [[0, 1, 1, 1, 1, 0, 1, 0], 218, 189],
 '123': [[0, 1, 1, 1, 1, 0, 1, 1], 33, 3],
 '124': [[0, 1, 1, 1, 1, 1, 0, 0], 16, 1],
 '125': [[0, 1, 1, 1, 1, 1, 0, 1], 255, 19],
 '126': [[0, 1, 1, 1, 1, 1, 1, 0], 243, 138],
 '127': [[0, 1, 1, 1, 1, 1, 1, 1], 210, 107],
 '128': [[1, 0, 0, 0, 0, 0, 0, 0], 205, 58],
 '129': [[1, 0, 0, 0, 0, 0, 0, 1], 12, 145],
 '130': [[1, 0, 0, 0, 0, 0, 1, 0], 19, 17],
 '131': [[1, 0, 0, 0, 0, 0, 1, 1], 236, 65],
 '132': [[1, 0, 0, 0, 0, 1, 0, 0], 95, 79],
 '133': [[1, 0, 0, 0, 0, 1, 0, 1], 151, 103],
 '134': [[1, 0, 0, 0, 0, 1, 1, 0], 68, 220],
 '135': [[1, 0, 0, 0, 0, 1, 1, 1], 23, 234],
 '136': [[1, 0, 0, 0, 1, 0, 0, 0], 196, 151],
 '137': [[1, 0, 0, 0, 1, 0, 0, 1], 167, 242],
 '138': [[1, 0, 0, 0, 1, 0, 1, 0], 126, 207],
 '139': [[1, 0, 0, 0, 1, 0, 1, 1], 61, 206],
 '140': [[1, 0, 0, 0, 1, 1, 0, 0], 100, 240],
 '141': [[1, 0, 0, 0, 1, 1, 0, 1], 93, 180],
 '142': [[1, 0, 0, 0, 1, 1, 1, 0], 25, 230],
 '143': [[1, 0, 0, 0, 1, 1, 1, 1], 115, 115],
 '144': [[1, 0, 0, 1, 0, 0, 0, 0], 96, 150],
 '145': [[1, 0, 0, 1, 0, 0, 0, 1], 129, 172],
 '146': [[1, 0, 0, 1, 0, 0, 1, 0], 79, 116],
 '147': [[1, 0, 0, 1, 0, 0, 1, 1], 220, 34],
 '148': [[1, 0, 0, 1, 0, 1, 0, 0], 34, 231],
 '149': [[1, 0, 0, 1, 0, 1, 0, 1], 42, 173],
 '150': [[1, 0, 0, 1, 0, 1, 1, 0], 144, 53],
 '151': [[1, 0, 0, 1, 0, 1, 1, 1], 136, 133],
 '152': [[1, 0, 0, 1, 1, 0, 0, 0], 70, 226],
 '153': [[1, 0, 0, 1, 1, 0, 0, 1], 238, 249],
 '154': [[1, 0, 0, 1, 1, 0, 1, 0], 184, 55],
 '155': [[1, 0, 0, 1, 1, 0, 1, 1], 20, 232],
 '156': [[1, 0, 0, 1, 1, 1, 0, 0], 222, 28],
 '157': [[1, 0, 0, 1, 1, 1, 0, 1], 94, 117],
 '158': [[1, 0, 0, 1, 1, 1, 1, 0], 11, 223],
 '159': [[1, 0, 0, 1, 1, 1, 1, 1], 219, 110],
 '160': [[1, 0, 1, 0, 0, 0, 0, 0], 224, 71],
 '161': [[1, 0, 1, 0, 0, 0, 0, 1], 50, 241],
 '162': [[1, 0, 1, 0, 0, 0, 1, 0], 58, 26],
 '163': [[1, 0, 1, 0, 0, 0, 1, 1], 10, 113],
 '164': [[1, 0, 1, 0, 0, 1, 0, 0], 73, 29],
 '165': [[1, 0, 1, 0, 0, 1, 0, 1], 6, 41],
 '166': [[1, 0, 1, 0, 0, 1, 1, 0], 36, 197],
 '167': [[1, 0, 1, 0, 0, 1, 1, 1], 92, 137],
 '168': [[1, 0, 1, 0, 1, 0, 0, 0], 194, 111],
 '169': [[1, 0, 1, 0, 1, 0, 0, 1], 211, 183],
 '170': [[1, 0, 1, 0, 1, 0, 1, 0], 172, 98],
 '171': [[1, 0, 1, 0, 1, 0, 1, 1], 98, 14],
 '172': [[1, 0, 1, 0, 1, 1, 0, 0], 145, 170],
 '173': [[1, 0, 1, 0, 1, 1, 0, 1], 149, 24],
 '174': [[1, 0, 1, 0, 1, 1, 1, 0], 228, 190],
 '175': [[1, 0, 1, 0, 1, 1, 1, 1], 121, 27],
 '176': [[1, 0, 1, 1, 0, 0, 0, 0], 231, 252],
 '177': [[1, 0, 1, 1, 0, 0, 0, 1], 200, 86],
 '178': [[1, 0, 1, 1, 0, 0, 1, 0], 55, 62],
 '179': [[1, 0, 1, 1, 0, 0, 1, 1], 109, 75],
 '180': [[1, 0, 1, 1, 0, 1, 0, 0], 141, 198],
 '181': [[1, 0, 1, 1, 0, 1, 0, 1], 213, 210],
 '182': [[1, 0, 1, 1, 0, 1, 1, 0], 78, 121],
 '183': [[1, 0, 1, 1, 0, 1, 1, 1], 169, 32],
 '184': [[1, 0, 1, 1, 1, 0, 0, 0], 108, 154],
 '185': [[1, 0, 1, 1, 1, 0, 0, 1], 86, 219],
 '186': [[1, 0, 1, 1, 1, 0, 1, 0], 244, 192],
 '187': [[1, 0, 1, 1, 1, 0, 1, 1], 234, 254],
 '188': [[1, 0, 1, 1, 1, 1, 0, 0], 101, 120],
 '189': [[1, 0, 1, 1, 1, 1, 0, 1], 122, 205],
 '190': [[1, 0, 1, 1, 1, 1, 1, 0], 174, 90],
 '191': [[1, 0, 1, 1, 1, 1, 1, 1], 8, 244],
 '192': [[1, 1, 0, 0, 0, 0, 0, 0], 186, 31],
 '193': [[1, 1, 0, 0, 0, 0, 0, 1], 120, 221],
 '194': [[1, 1, 0, 0, 0, 0, 1, 0], 37, 168],
 '195': [[1, 1, 0, 0, 0, 0, 1, 1], 46, 51],
 '196': [[1, 1, 0, 0, 0, 1, 0, 0], 28, 136],
 '197': [[1, 1, 0, 0, 0, 1, 0, 1], 166, 7],
 '198': [[1, 1, 0, 0, 0, 1, 1, 0], 180, 199],
 '199': [[1, 1, 0, 0, 0, 1, 1, 1], 198, 49],
 '200': [[1, 1, 0, 0, 1, 0, 0, 0], 232, 177],
 '201': [[1, 1, 0, 0, 1, 0, 0, 1], 221, 18],
 '202': [[1, 1, 0, 0, 1, 0, 1, 0], 116, 16],
 '203': [[1, 1, 0, 0, 1, 0, 1, 1], 31, 89],
 '204': [[1, 1, 0, 0, 1, 1, 0, 0], 75, 39],
 '205': [[1, 1, 0, 0, 1, 1, 0, 1], 189, 128],
 '206': [[1, 1, 0, 0, 1, 1, 1, 0], 139, 236],
 '207': [[1, 1, 0, 0, 1, 1, 1, 1], 138, 95],
 '208': [[1, 1, 0, 1, 0, 0, 0, 0], 112, 96],
 '209': [[1, 1, 0, 1, 0, 0, 0, 1], 62, 81],
 '210': [[1, 1, 0, 1, 0, 0, 1, 0], 181, 127],
 '211': [[1, 1, 0, 1, 0, 0, 1, 1], 102, 169],
 '212': [[1, 1, 0, 1, 0, 1, 0, 0], 72, 25],
 '213': [[1, 1, 0, 1, 0, 1, 0, 1], 3, 181],
 '214': [[1, 1, 0, 1, 0, 1, 1, 0], 246, 74],
 '215': [[1, 1, 0, 1, 0, 1, 1, 1], 14, 13],
 '216': [[1, 1, 0, 1, 1, 0, 0, 0], 97, 45],
 '217': [[1, 1, 0, 1, 1, 0, 0, 1], 53, 229],
 '218': [[1, 1, 0, 1, 1, 0, 1, 0], 87, 122],
 '219': [[1, 1, 0, 1, 1, 0, 1, 1], 185, 159],
 '220': [[1, 1, 0, 1, 1, 1, 0, 0], 134, 147],
 '221': [[1, 1, 0, 1, 1, 1, 0, 1], 193, 201],
 '222': [[1, 1, 0, 1, 1, 1, 1, 0], 29, 156],
 '223': [[1, 1, 0, 1, 1, 1, 1, 1], 158, 239],
 '224': [[1, 1, 1, 0, 0, 0, 0, 0], 225, 160],
 '225': [[1, 1, 1, 0, 0, 0, 0, 1], 248, 224],
 '226': [[1, 1, 1, 0, 0, 0, 1, 0], 152, 59],
 '227': [[1, 1, 1, 0, 0, 0, 1, 1], 17, 77],
 '228': [[1, 1, 1, 0, 0, 1, 0, 0], 105, 174],
 '229': [[1, 1, 1, 0, 0, 1, 0, 1], 217, 42],
 '230': [[1, 1, 1, 0, 0, 1, 1, 0], 142, 245],
 '231': [[1, 1, 1, 0, 0, 1, 1, 1], 148, 176],
 '232': [[1, 1, 1, 0, 1, 0, 0, 0], 155, 200],
 '233': [[1, 1, 1, 0, 1, 0, 0, 1], 30, 235],
 '234': [[1, 1, 1, 0, 1, 0, 1, 0], 135, 187],
 '235': [[1, 1, 1, 0, 1, 0, 1, 1], 233, 60],
 '236': [[1, 1, 1, 0, 1, 1, 0, 0], 206, 131],
 '237': [[1, 1, 1, 0, 1, 1, 0, 1], 85, 83],
 '238': [[1, 1, 1, 0, 1, 1, 1, 0], 40, 153],
 '239': [[1, 1, 1, 0, 1, 1, 1, 1], 223, 97],
 '240': [[1, 1, 1, 1, 0, 0, 0, 0], 140, 23],
 '241': [[1, 1, 1, 1, 0, 0, 0, 1], 161, 43],
 '242': [[1, 1, 1, 1, 0, 0, 1, 0], 137, 4],
 '243': [[1, 1, 1, 1, 0, 0, 1, 1], 13, 126],
 '244': [[1, 1, 1, 1, 0, 1, 0, 0], 191, 186],
 '245': [[1, 1, 1, 1, 0, 1, 0, 1], 230, 119],
 '246': [[1, 1, 1, 1, 0, 1, 1, 0], 66, 214],
 '247': [[1, 1, 1, 1, 0, 1, 1, 1], 104, 38],
 '248': [[1, 1, 1, 1, 1, 0, 0, 0], 65, 225],
 '249': [[1, 1, 1, 1, 1, 0, 0, 1], 153, 105],
 '250': [[1, 1, 1, 1, 1, 0, 1, 0], 45, 20],
 '251': [[1, 1, 1, 1, 1, 0, 1, 1], 15, 99],
 '252': [[1, 1, 1, 1, 1, 1, 0, 0], 176, 85],
 '253': [[1, 1, 1, 1, 1, 1, 0, 1], 84, 33],
 '254': [[1, 1, 1, 1, 1, 1, 1, 0], 187, 12],
 '255': [[1, 1, 1, 1, 1, 1, 1, 1], 22, 125],
}

List_base_256_to_letters = [
 'ķ', 'Ó', 'Ū', 'á', 'ų', 'Õ', 'H', 'n', 'č', 's', 'ŏ', 'ż', 'Ķ', 'ĺ', 'ŕ', 'Ą', 'K', '%', 'Ć', 'Ā', 
 '×', 'ģ', 'æ', 'U', '8', 'þ', 'Ŏ', 'F', 'Ĭ', 'ŵ', 'c', 'Ô', 'Ō', 'É', 'ő', '6', '<', 'ű', 'Ä', 'À', 
 'Ę', 'İ', 'ä', 'Í', 't', 'Ù', 'Ã', 'ø', 'ò', 'Ê', 'Ò', 'Ļ', 'ţ', 'G', 'ū', 'Ě', 'Ź', '_', 'ē', 'E', 
 'ę', 'œ', 'g', 'ě', 'e', 'ï', 'Ų', 'N', 'Q', 'Î', 'Ł', 'ļ', 'A', 'Ś', 'ą', '[', 'ã', 'Ċ', 'v', 'Ţ', 
 ']', 'ŋ', 'Y', 'Ľ', 'ź', ',', 'ó', 'ů', '"', 'Á', 'Ň', 'È', 'J', 'Đ', 'Ű', 'ü', '.', 'ô', 'Å', 'Ă', 
 'î', 'ö', '9', '~', 'p', 'â', 'b', 'ň', '@', 'Š', 'a', 'Â', 'ð', 'õ', 'Ç', 'Ŷ', 'M', '3', '+', 'Ð', 
 'X', 'Ő', ';', 'ì', 'Ÿ', 'ć', 'Ø', 'm', 'ł', 'Û', 'ď', '|', '4', 'Ĺ', 'D', 'ÿ', 'ë', 'à', 'Č', 'ņ', 
 'h', '7', '>', '1', '=', 'ō', 'Ñ', 'C', 'y', '2', 'ń', 'ĩ', 'Ş', 'Ŕ', 'o', '/', 'z', 'u', '0', 'Į',
 'j', 'į', "'", 'ı', 'Ë', '*', 'Ż', 'B', 'w', 'é', 'đ', 'Ž', 'Ř', 'Ú', 'L', 'Ė', 'Ì', 'ś', 'V', 'Ï', 
 'Ī', 'P', '^', '&', 'R', 'å', 'ş', 'f', 'ī', 'ř', 'ğ', 'è', '?', 'i', 'ŷ', 'ā', 'T', 'ß', 'Ģ', 'I', 
 'W', 'Þ', '`', 'ç', 'í', ' ', 'Ņ', '\n', '#', 'Z', '÷', 'ė', 'r', 'ă', 'Ö', 'q', 'k', 'ľ', 'ê', 'ž', 
 'ù', 'Ń', 'Ť', 'ĭ', 'ý', 'Ů', 'Ğ', 'ñ', 'Ē', '}', 'Ý', '$', 'O', 'S', 'Ĩ', 'x', '-', 'l', 'Ď', 'š', 
 '{', '(', '\\', 'ú', 'Ü', 'Œ', 'd', '5', 'û', ')', 'ť', '!', 'Æ', ':', 'Ŵ', 'Ŋ'
 ]

dictionary_letters_to_base_256 = {
 'ķ': 0, 'Ó': 1, 'Ū': 2, 'á': 3, 'ų': 4, 'Õ': 5, 'H': 6, 'n': 7, 'č': 8, 's': 9, 'ŏ': 10, 'ż': 11, 'Ķ': 12, 
 'ĺ': 13, 'ŕ': 14, 'Ą': 15, 'K': 16, '%': 17, 'Ć': 18, 'Ā': 19, '×': 20, 'ģ': 21, 'æ': 22, 'U': 23, '8': 24,
 'þ': 25, 'Ŏ': 26, 'F': 27, 'Ĭ': 28, 'ŵ': 29, 'c': 30, 'Ô': 31, 'Ō': 32, 'É': 33, 'ő': 34, '6': 35, '<': 36,
 'ű': 37, 'Ä': 38, 'À': 39, 'Ę': 40, 'İ': 41, 'ä': 42, 'Í': 43, 't': 44, 'Ù': 45, 'Ã': 46, 'ø': 47, 'ò': 48,
 'Ê': 49, 'Ò': 50, 'Ļ': 51, 'ţ': 52, 'G': 53, 'ū': 54, 'Ě': 55, 'Ź': 56, '_': 57, 'ē': 58, 'E': 59, 'ę': 60, 
 'œ': 61, 'g': 62, 'ě': 63, 'e': 64, 'ï': 65, 'Ų': 66, 'N': 67, 'Q': 68, 'Î': 69, 'Ł': 70, 'ļ': 71, 'A': 72, 
 'Ś': 73, 'ą': 74, '[': 75, 'ã': 76, 'Ċ': 77, 'v': 78, 'Ţ': 79, ']': 80, 'ŋ': 81, 'Y': 82, 'Ľ': 83, 'ź': 84,
 ',': 85, 'ó': 86, 'ů': 87, '"': 88, 'Á': 89, 'Ň': 90, 'È': 91, 'J': 92, 'Đ': 93, 'Ű': 94, 'ü': 95, '.': 96, 
 'ô': 97, 'Å': 98, 'Ă': 99, 'î': 100, 'ö': 101, '9': 102, '~': 103, 'p': 104, 'â': 105, 'b': 106, 'ň': 107, '@': 108, 
 'Š': 109, 'a': 110, 'Â': 111, 'ð': 112, 'õ': 113, 'Ç': 114, 'Ŷ': 115, 'M': 116, '3': 117, '+': 118, 'Ð': 119, 'X': 120,
 'Ő': 121, ';': 122, 'ì': 123, 'Ÿ': 124, 'ć': 125, 'Ø': 126, 'm': 127, 'ł': 128, 'Û': 129, 'ď': 130, '|': 131, '4': 132,
 'Ĺ': 133, 'D': 134, 'ÿ': 135, 'ë': 136, 'à': 137, 'Č': 138, 'ņ': 139, 'h': 140, '7': 141, '>': 142, '1': 143, '=': 144,
 'ō': 145, 'Ñ': 146, 'C': 147, 'y': 148, '2': 149, 'ń': 150, 'ĩ': 151, 'Ş': 152, 'Ŕ': 153, 'o': 154, '/': 155, 'z': 156,
 'u': 157, '0': 158, 'Į': 159, 'j': 160, 'į': 161, "'": 162, 'ı': 163, 'Ë': 164, '*': 165, 'Ż': 166, 'B': 167, 'w': 168,
 'é': 169, 'đ': 170, 'Ž': 171, 'Ř': 172, 'Ú': 173, 'L': 174, 'Ė': 175, 'Ì': 176, 'ś': 177, 'V': 178, 'Ï': 179, 'Ī': 180,
 'P': 181, '^': 182, '&': 183, 'R': 184, 'å': 185, 'ş': 186, 'f': 187, 'ī': 188, 'ř': 189, 'ğ': 190, 'è': 191, '?': 192,
 'i': 193, 'ŷ': 194, 'ā': 195, 'T': 196, 'ß': 197, 'Ģ': 198, 'I': 199, 'W': 200, 'Þ': 201, '`': 202, 'ç': 203, 'í': 204,
 ' ': 205, 'Ņ': 206, '\n': 207, '#': 208, 'Z': 209, '÷': 210, 'ė': 211, 'r': 212, 'ă': 213, 'Ö': 214, 'q': 215, 'k': 216,
 'ľ': 217, 'ê': 218, 'ž': 219, 'ù': 220, 'Ń': 221, 'Ť': 222, 'ĭ': 223, 'ý': 224, 'Ů': 225, 'Ğ': 226, 'ñ': 227, 'Ē': 228,
 '}': 229, 'Ý': 230, '$': 231, 'O': 232, 'S': 233, 'Ĩ': 234, 'x': 235, '-': 236, 'l': 237, 'Ď': 238, 'š': 239, '{': 240,
 '(': 241, '\\': 242, 'ú': 243, 'Ü': 244, 'Œ': 245, 'd': 246, '5': 247, 'û': 248, ')': 249, 'ť': 250, '!': 251, 'Æ': 252,
 ':': 253, 'Ŵ': 254, 'Ŋ': 255
 }

def Sub_Bytes(matrix_SB, bool_encrypt):
    """
    The Sub_Bytes function takes a 4x4 list (matrix_SB), and returns a 4x4 list (mat_sb).
    To generate an element in matrix_SB: the value of the respective element in the matrix_SB 
    is used as a key in the dictionary, dictionary, and returns either the second item (if 
    encrypting) or third item (if decrypting) in that list.
    When bool_encrypt is true - then encrypting and if bool_encrypt is false - then decrypting.
    
    For encrypting:
    
    [b7,b6, b5, b4, b3, b2, b1, b0] is the first item in the dictionary, dictionary, with the respective
    element in matrix_SB.
    
    [s7,s6, s5, s4, s3, s2, s1, s0] is the first item in the dictionary, dictionary, with its key the
    respective output element in mat_sb
    
    The values in the dictionary for encrypting is the value of the dictionary key mapped to its 
    multiplicative inverse in Rijndael's finite field followed by the following affine transformation:

    [[s0],              [[1,0,0,0,1,1,1,1],       [[b0],                       [[1],
    [s1],               [1,1,0,0,0,1,1,1],        [b1],                        [1],
    [s2],               [1,1,1,0,0,0,1,1],        [b2],                        [0],
    [s3],     =         [1,1,1,1,0,0,0,1],        [b3],           +            [0],
    [s4],               [1,1,1,1,1,0,0,0],        [b4],                        [0],
    [s5],               [0,1,1,1,1,1,0,0],        [b5],                        [1],
    [s6],               [0,0,1,1,1,1,1,0],        [b6],                        [1],
    [s7]]               [0,0,0,1,1,1,1,1]]        [b7]]                        [0]]

    

    For decrypting:

    [s7,s6, s5, s4, s3, s2, s1, s0] is the first item in the dictionary, dictionary, with the respective
    element in matrix_SB.
    
    [b7,b6, b5, b4, b3, b2, b1, b0] is the first item in the dictionary, dictionary, with its key the
    respective output element in mat_sb

    The values in the dictionary for decrypting is the value of the dictionary key mapped to its
    multiplicative inverse in Rijndael's finite field followed by the following affine transformation:
    [[b0],              [[0,0,1,0,0,1,0,1],       [[s0],                       [[1],
    [b1],               [1,0,0,1,0,0,1,0],        [s1],                        [0],
    [b2],               [0,1,0,0,1,0,0,1],        [s2],                        [1],
    [b3],     =         [1,0,1,0,0,1,0,0],        [s3],           +            [0],
    [b4],               [0,1,0,1,0,0,1,0],        [s4],                        [0],
    [b5],               [0,0,1,0,1,0,0,1],        [s5],                        [0],
    [b6],               [1,0,0,1,0,1,0,0],        [s6],                        [0],
    [b7]]               [0,1,0,0,1,0,1,0]]        [s7]]                        [0]]
    """

    number_1 = 2 - bool_encrypt
    mat_sb = [
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0]
        ]
    for i in range(4):
        for j in range(4):
            mat_sb[i][j] = dictionary[str(matrix_SB[i][j])][number_1]
    return mat_sb

def Rotate_Rows(matrix_RR, bool_encrypt):
    """
    The Rotate_Rows function takes a 4x4 list (matrix_RR) and a boolean (bool_encrypt) and returns
    a 4x4 list (mat_rr). 
    The purpose of the function is to shift the elements in each row of the 
    list by a specific amount, which is shown below.
    When bool_encrypt is true - then encrypting and if bool_encrypt is false - then decrypting.

    If encypting:
    
        matrix_RR                  ->       mat_rr

        [[a00, a01, a02, a03],              [[a00, a01, a02, a03],
         [a10, a11, a12, a13],     ->        [a11, a12, a13, a10],
         [a20, a21, a22, a23],               [a22, a23, a20, a21],
         [a30, a31, a32, a33]]               [a33, a30, a31, a32]]

    if decrypting:
    
        matrix_RR                  ->       mat_rr

        [[a00, a01, a02, a03],              [[a00, a01, a02, a03],
         [a10, a11, a12, a13],      ->       [a13, a10, a11, a12],
         [a20, a21, a22, a23],               [a22, a23, a20, a21],
         [a30, a31, a32, a33]]               [a31, a32, a33, a30]]

    """
    number_2 = 2*bool_encrypt-1
    mat_rr = [matrix_RR[0]]
    length_matrix_RR = len(matrix_RR)
    for i in range(1,length_matrix_RR):
        mat_rr += [matrix_RR[i][(number_2*i):]+matrix_RR[i][:(number_2*i)]]
    return mat_rr

def Mix_Columns(matrix_MC, bool_encrypt):
    """
    The function Mix_Columns takes a 4x4 integer list (matrix_MC) and boolean (bool_encrypt) and returns
    a 4x4 list (mat_mc)

    The purpose of the function is to matrix multiply the matrix_MC and matrix matrix_permanent_mc
    in a Galois Field of order 256.
    When bool_encrypt is true - then encrypting and if bool_encrypt is false - then decrypting.

    If encrypting:
        matrix_permanent_mc = [
            [2,3,1,1],
            [1,2,3,1],
            [1,1,2,3],
            [3,1,1,2],
        ]

    If decrypting:
        matrix_permanent_mc = [
            [14,11,13,9],
            [9,14,11,13],
            [13,9,14,11],
            [11,13,9,14],
        ]        
    """
    mat_mc = [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
    ]

    if bool_encrypt:
        matrix_permanent_mc = [
            [2,3,1,1],
            [1,2,3,1],
            [1,1,2,3],
            [3,1,1,2],
        ]
    else:
        matrix_permanent_mc = [
            [14,11,13,9],
            [9,14,11,13],
            [13,9,14,11],
            [11,13,9,14]
        ]
        
    for k in range(0,4):
        column = [matrix_MC[0][k],matrix_MC[1][k],matrix_MC[2][k],matrix_MC[3][k]]
        for j in range(4):
            integer_temporary_mc = 0
            for i in range(4):
                I_M_XOR = integer_multiplication_XOR(integer_fixed_m_m_XOR=column[i], integer_temporary_m_m_XOR=matrix_permanent_mc[j][i])
                integer_temporary_mc = integer_temporary_mc ^ I_M_XOR
            integer_m_c_j_k = integer_multiplication_XOR(integer_fixed_m_m_XOR=283, integer_temporary_m_m_XOR=integer_temporary_mc//256) ^ integer_temporary_mc
            mat_mc[j][k] = integer_m_c_j_k
    return mat_mc

def Round_Key_Value(matrix_RKV):
    """
    The function Round_Key_Value takes a 4x4 list (matrix_RKV) and outputs a list
    of 11 4x4 lists (mat_rkv)
    The purpose of the function is to expand the input 4x4 list by the AES Key expansion algoritm.
    """
    List_Rcon = [0,1,2,4,8,16,32,64,128,27,54]
    matrix_rm_rkv = Rotate_Matrix(matrix_RM=matrix_RKV)
    matrix_temporary_rkv = matrix_rm_rkv[3][1:] + matrix_rm_rkv[3][:1]
    for i in range(1,11):
        for j in range(4):
            matrix_temporary_rkv[j] = dictionary[str(matrix_temporary_rkv[j])][1]
        matrix_temporary_rkv[0] = List_Rcon[i] ^ matrix_temporary_rkv[0]
        for k in range(4):
            for l in range(4):
                matrix_temporary_rkv[l] = matrix_temporary_rkv[l] ^ matrix_rm_rkv[4*(i-1) + k][l]
            matrix_rm_rkv.append(matrix_temporary_rkv[:])
        matrix_temporary_rkv = matrix_temporary_rkv[1:]+matrix_temporary_rkv[:1]
    mat_rkv=[]
    for i in range(11):
        mat_rkv += [Rotate_Matrix(matrix_RM=matrix_rm_rkv[4*i:4*(i+1)])]
    return mat_rkv

def After_Round_Key_Value(matrix_ARKV, matrix_RKV_m):
    """
    The After_Round_Key_value function takes 2 4x4 integer lists (matrix_ARKV and matrix_RKV_m) and
    returns a 4x4 list (mat_arkv).

    The purpose of the function is to take 2 4x4 integer lists and return a 4x4 integer list with the
    binary XOR of each element in one list with the respective element in the other list.
    """
    mat_arkv = [
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0]
        ]
    for i in range(4):
        for j in range(4):
            mat_arkv[i][j] = matrix_ARKV[i][j] ^ matrix_RKV_m[i][j]
    return mat_arkv

def HEX(matrix_HEX):
    """
    The HEX function takes a 4x4 list (matrix_HEX) and returns a 4x4 list (mat_hex).
    The purpose of the function is take a 4x4 list of decimal integers (matrix_HEX) and return 
    a 4x4 list of the respective hexadecimal integers.
    Below is an example.

    matrix_RR                      ->       mat_rr

       [[ 03, 140,  95, 201],             [[03, 8c, 5f, c9],
        [161, 217,  12, 115],     ->       [a1, d9, 0b, 73],
        [ 37,  58,  70, 191],              [25, 3a, 46, bf],
        [109, 123,  46,  28]]              [6d, 7b, 2e, 1c]]
    """
    mat_hex = [
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0]
        ]
    for i in range(4):
        for j in range(4):
            mat_hex[i][j] = hex(matrix_HEX[i][j])[2:]
            if len(mat_hex[i][j]) == 1:
                mat_hex[i][j] = '0' + mat_hex[i][j]
    return(mat_hex)


def Rotate_Matrix(matrix_RM):
    """
    The Rotate_Matrix function takes a 4x4 list (matrix_RM) and returns a 4x4 list (mat_rm).

    The purpose of the function is to swap the rows of the list with the columns.

    matrix_RM                  ->       mat_rm

    [[a00, a01, a02, a03],              [[a00, a10, a20, a30],
     [a10, a11, a12, a13],     ->        [a01, a11, a21, a31],
     [a20, a21, a22, a23],               [a02, a12, a22, a32],
     [a30, a31, a32, a33]]               [a03, a13, a23, a33]]
    """

    mat_rm = [
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0]
        ]
    for i in range(4):
        for j in range(4):
            mat_rm[i][j] = matrix_RM[j][i]
    return mat_rm

def integer_multiplication_XOR(integer_fixed_m_m_XOR,integer_temporary_m_m_XOR):
    """"
    The function matrix_multiplication_XOR takes two integers (integer_fixed_m_m_XOR, integer_temporary_m_m_XOR) and returns an
    integer (integer_m_m_XOR)

    The purpose of the function is to carryless multiply 2 integers in base 2.
    """
    integer_m_m_XOR = 0
    list_binary_integer_temporary_m_m_XOR = dictionary[str(integer_temporary_m_m_XOR)][0]
    for i in range(8):
        if list_binary_integer_temporary_m_m_XOR[7-i]:
            integer_m_m_XOR = integer_m_m_XOR ^ (integer_fixed_m_m_XOR* 2**(i))
    return integer_m_m_XOR


def AES_Encrypt_unformatted(Plainmatrix, Key):
    """
    The AES_Encrypt_unformatted takes a 4x4 list of integers (Plainmatrix) and a 4x4 list (AES key Key)
    and returns a 4x4 list of integers (mat_aes_encrypt_unformatted).

    The purpose of the function is to encrypt the 4x4 list (Plainmatrix) with the AES encryption key (Key)
    using the algorithm for AES encryption.
    """

    matrix_temporary_aes_encrypt_unformatted = Plainmatrix[:]
    mat_rk_e = Round_Key_Value(matrix_RKV=Key)
    mat_aes_encrypt_unformatted = After_Round_Key_Value(matrix_ARKV=matrix_temporary_aes_encrypt_unformatted, matrix_RKV_m=mat_rk_e[0])
    for m in range(1,10):
        matrix_temporary_aes_encrypt_unformatted = Mix_Columns(matrix_MC=Rotate_Rows(matrix_RR=Sub_Bytes(matrix_SB=mat_aes_encrypt_unformatted, bool_encrypt=1), bool_encrypt=1), bool_encrypt=1)
        mat_aes_encrypt_unformatted = After_Round_Key_Value(matrix_ARKV=matrix_temporary_aes_encrypt_unformatted, matrix_RKV_m=mat_rk_e[m])
    matrix_temporary_aes_encrypt_unformatted = Rotate_Rows(matrix_RR=Sub_Bytes(matrix_SB=mat_aes_encrypt_unformatted, bool_encrypt=1), bool_encrypt=1)
    mat_aes_encrypt_unformatted = After_Round_Key_Value(matrix_ARKV=matrix_temporary_aes_encrypt_unformatted, matrix_RKV_m=mat_rk_e[10])
    return mat_aes_encrypt_unformatted

def AES_Decrypt_unformatted(Ciphermatrix, Key):
    """
    The AES_Decrypt_unformatted takes a 4x4 list of integers (Ciphermatrix) and 4x4 list (AES key Key)
    and returns a 4x4 list of integers (mat_aes_decrypt_unformatted).

    The purpose of the function is to decrypt the 4x4 list (Ciphermatrix) with the AES encryption key (Key)
    using the algorithm for AES decryption.
    """

    mat_rk_d = Round_Key_Value(matrix_RKV=Key)
    mat_aes_decrypt_unformatted = Sub_Bytes(matrix_SB=Rotate_Rows(matrix_RR=After_Round_Key_Value(matrix_ARKV=Ciphermatrix, matrix_RKV_m=mat_rk_d[10]), bool_encrypt=0), bool_encrypt=0)
    for i in range(9):
        mat_aes_decrypt_unformatted = Sub_Bytes(matrix_SB=Rotate_Rows(matrix_RR=Mix_Columns(matrix_MC=After_Round_Key_Value(matrix_ARKV=mat_aes_decrypt_unformatted,matrix_RKV_m=mat_rk_d[9-i]), bool_encrypt=0), bool_encrypt=0), bool_encrypt=0)
    mat_aes_decrypt_unformatted = After_Round_Key_Value(matrix_ARKV=mat_aes_decrypt_unformatted, matrix_RKV_m=Key)
    return mat_aes_decrypt_unformatted


def format_string_2_4x4_matrices (string_F_S_2_4x4_M):
    """
    The function format_intial takes a string (string) and returns a list of 4x4 lists
    (matrix_string_F_S_2_4x4_M)

    The purpose of the function is to take a string and convert it into a list of 4x4 lists
    where each element is an intger
    """
    length_string_F_S_2_4x4_M = len(string_F_S_2_4x4_M)
    integer_temp_f_i = ((-length_string_F_S_2_4x4_M) %16)
    for i in range(integer_temp_f_i):
        string_F_S_2_4x4_M += '@'
    number_of_matricies = int(len(string_F_S_2_4x4_M)/16)
    matrix_string_F_S_2_4x4_M = []
    for i in range(number_of_matricies):
        matrix_string_F_S_2_4x4_M.append([
                ['','','',''],
                ['','','',''],
                ['','','',''],
                ['','','',''],
            ]
        )
        for j in range(4):
            for k in range(4):
                matrix_string_F_S_2_4x4_M[i][k][j] = dictionary_letters_to_base_256[string_F_S_2_4x4_M[16*i+4*j+k]]
    return matrix_string_F_S_2_4x4_M

def format_AES(matrix_F_AES, Key, bool_encrypt):
    """
    The function format_middle takes a list of 4x4 integer lists (matrix_F_AES), a 4x4 list (AES key Key) and
    a boolean (bool_encrypt) and returns a list of 4x4 integer lists (matrix_fm)

    The purpose of this function is to take a list of 4x4 integer lists and either encrypts or decrypts them
    with the 4x4 list (AES key), depending on the boolean bool_encrypt.
    bool_encrypt is 0 for decryption and 1 for encryption.
    """
    length_matrix_F_AES = len(matrix_F_AES)
    matrix_f_AES = []
    if bool_encrypt:
        for i in range(length_matrix_F_AES):
            matrix_f_AES.append(AES_Encrypt_unformatted(Plainmatrix=matrix_F_AES[i], Key=Key))
    else:
        for i in range(length_matrix_F_AES):
            matrix_f_AES.append(AES_Decrypt_unformatted(Ciphermatrix=matrix_F_AES[i], Key=Key))
    return matrix_f_AES

def format_4x4_matricies_2_string(matrix_F_4x4_M_2_S):
    """
    The function format_final takes a list of 4x4 lists of integer characters (matrix_F_4x4_M_2_S) and returns a
    string (string_f_4x4_m_2_s).

    The purpose of the function is to take a list of 4x4 list of integer characters and add those string
    characters together and return a string.
    """
    length_matrix_F_4x4_M_2_S = len(matrix_F_4x4_M_2_S)
    string_f_4x4_m_2_s = ''
    for i in range(length_matrix_F_4x4_M_2_S):
        for j in range(4):
            for k in range(4):
                string_f_4x4_m_2_s += List_base_256_to_letters[matrix_F_4x4_M_2_S[i][k][j]]
    return string_f_4x4_m_2_s

def format_final_decrypt(string_format_final):
    """
    The function format_final_decrypt takes a string (string_format_final) and returns a string (string_format_final_decrypt)
    
    The purpose of the function is to remove any '@' from the end of the input string.
    """
    count = 0
    for i in range(1,16):
        if (string_format_final[-i]) == '@' and (i == count+1):
            count += 1
        else:
            break
    if count == 0:
        string_format_final_decrypt = string_format_final[:]
        return string_format_final_decrypt
    string_format_final_decrypt = string_format_final[:-count]
    return string_format_final_decrypt

def input_checker(Input_text):
    """
    The function input_checker takes a string (Input_text) and returns either a string or a list.

    The purpose of the function is to check if the input string is empty or if there are any characters
    in the string not in the dictionary dictionary_letters_to_base_256. It returns a list with the input
    string if that is the case, otherwise it returns the input string.
    """
    non_standard_character = 0
    if len(Input_text) == 0:
        print('no input detected, please try again')
        non_standard_character = 1
    for character in Input_text:
        if not character in dictionary_letters_to_base_256:
            non_standard_character += 1
            print('Please try again with a different character to {}'.format(character))
    if non_standard_character > 0:
        return [Input_text]
    return Input_text

def format(Input_text, Key, bool_encrypt):
    """
    The function format takes a string (Input_text), 4x4 list (AES key Key) and boolean (bool_encrypt) and
    returns a string (string_format_final)

    This function converts a string into a list of 4x4 matricies, encrypts or decrypts those lists with the
    given AES key and then coverts the 4x4 matricies back into a string
    """
    matrix_format_initial = format_string_2_4x4_matrices(string_F_S_2_4x4_M=Input_text)
    matrix_format_middle = format_AES(matrix_F_AES=matrix_format_initial, Key=Key, bool_encrypt=bool_encrypt)
    string_format_final = format_4x4_matricies_2_string(matrix_F_4x4_M_2_S=matrix_format_middle)
    return(string_format_final)
    
def Key_String_2_4x4_Matrix(string_K_S_2_4x4_M):
    """
    The function Key_String_2_4x4_matrix takes a string (string_K_S_2_4x4_M) and returns a either a 4x4 list (Key)
    or a string (string_K_S_2_4x4_M)
    If the string has less than 16 characters or if there are any characters in the string not in the dictionary
    dictionary_letters_to_base_256, then the function returns string.
    Else it returns the list (Key)

    The purpose of the function is to turn a string into a 4x4 list for an AES Key.
    """
    if not type(string_K_S_2_4x4_M) == str:
        string_K_S_2_4x4_M = "Key needs to be a string"
        print("Key needs to be a string")
        return string_K_S_2_4x4_M
    if len(string_K_S_2_4x4_M) < 16:
        print("Key needs to be at least 16 characters")
        return string_K_S_2_4x4_M
    string_K_S_2_4x4_M = string_K_S_2_4x4_M[:16]
    Key = input_checker(Input_text=string_K_S_2_4x4_M)
    if type(Key) == list:
        return string_K_S_2_4x4_M
    Key = format_string_2_4x4_matrices(string_F_S_2_4x4_M=Key)[0]
    return Key
    
def AES_Encrypt(Plaintext, Key):
    """
    The function AES_Encrypt takes a string (Plaintext) and a AES key (Key) and returns a string.

    The purpose of the function is to encrypt the input string with AES encryption with the given AES key.
    """
    Plaintext = input_checker(Input_text=Plaintext)
    Key = Key_String_2_4x4_Matrix(string_K_S_2_4x4_M=Key)
    if type(Plaintext) == list:
        return Plaintext[0]
    
    if type(Key) == str:
        return Plaintext
    
    return format(Input_text=Plaintext, Key=Key, bool_encrypt=1)

def AES_Decrypt(Ciphertext, Key):
    """
    The function AES_Decrypt takes a string (Ciphertext) and a AES key (Key) and returns a string.

    The purpose of the function is to decrypt the input string with AES decryption with the given AES key.
    """
    Ciphertext = input_checker(Input_text=Ciphertext)
    Key = Key_String_2_4x4_Matrix(string_K_S_2_4x4_M=Key)
    if type(Ciphertext) == list:
        return Ciphertext[0]
    
    if type(Key) == str:
        return Ciphertext
    Plain_text = format(Input_text=Ciphertext, Key=Key, bool_encrypt=0)
    Plain_text = format_final_decrypt(string_format_final=Plain_text)
    return Plain_text

def AES_Encrypt_Decrypt_file(Filename, Key, bool_encrypt):
    """
    The function AES_Encrypt_Decrypt_file takes 2 strings (Filename and Key) and a boolean (bool_encrypt)
    and does not return anything.

    The purpose of the function is to encrypt or decrypt the file with the name (Filename) with the given
    AES key string (Key).
    """
    try:
        with open(Filename,'r', encoding='utf-8') as f:
            input_text = f.read()
            f.close()
    except FileNotFoundError:
        print("File not found, please type the file name correctly or create the file")
        return

    if bool_encrypt:
        output_text = AES_Encrypt(Plaintext=input_text, Key=Key)
    else:
        output_text= AES_Decrypt(Ciphertext=input_text, Key=Key)
    
    with open(Filename,'w', encoding='utf-8') as f:
        f.write(output_text)
        f.close()

    if bool_encrypt and not(output_text==input_text):
        print("{} successfully encrypted".format(Filename))
        return
    if not(bool_encrypt) and not(output_text==input_text) :
        print("{} successfully decrypted".format(Filename))